1. ✅ **Add Database Models**  
   - Open **`prisma/schema.prisma`**.
   - Below the existing `model Session { ... }` definition, add the following models:
     ```prisma
     model Model {
       id         String    @id @default(cuid())
       name       String
       baseUrl    String
       apiKey     String
       createdAt  DateTime  @default(now())
       Evals      Eval[]
     }

     model Eval {
       id              String    @id @default(cuid())
       questionText    String
       creatorModelId  String
       tags            String?
       difficulty      Int?
       createdAt       DateTime  @default(now())
       creatorModel    Model     @relation(fields: [creatorModelId], references: [id])
       Results         Result[]
       Judgments       Judgment[]
     }

     model Result {
       id           String   @id @default(cuid())
       evalId       String
       modelId      String
       responseText String?
       errorLog     String?
       timestamp    DateTime @default(now())
       Eval         Eval     @relation(fields: [evalId], references: [id])
       Model        Model    @relation(fields: [modelId], references: [id])
     }

     model Judgment {
       id               String   @id @default(cuid())
       evalId           String
       judgeModelId     String
       score            Float
       justificationText String?
       timestamp        DateTime @default(now())
       Eval             Eval     @relation(fields: [evalId], references: [id])
       judgeModel       Model    @relation("JudgeModel", fields: [judgeModelId], references: [id])
     }
     ```
   - Save **`schema.prisma`**.

2. ✅ **Run Migrations**  
   - From the project root, run:  
     ```bash
     npx prisma migrate dev --name add-llm-eval-tables
     ```

3. ✅ **Create Model Routers**  
   - Create a new folder **`src/lib/api/routers`** if it doesn't exist.
   - Inside this folder, create a file **`modelRouter.ts`**:
     ```ts
     import { z } from "zod";
     import { createTRPCRouter, publicProcedure, protectedProcedure } from "../trpc";
     import { prisma } from "@/lib/db";

     export const modelRouter = createTRPCRouter({
       createModel: protectedProcedure
         .input(
           z.object({
             name: z.string(),
             baseUrl: z.string(),
             apiKey: z.string(),
           })
         )
         .mutation(async ({ input }) => {
           const model = await prisma.model.create({
             data: {
               name: input.name,
               baseUrl: input.baseUrl,
               apiKey: input.apiKey,
             },
           });
           return model;
         }),

       listModels: publicProcedure.query(async () => {
         const models = await prisma.model.findMany();
         return models;
       }),

       updateModel: protectedProcedure
         .input(
           z.object({
             id: z.string(),
             name: z.string().optional(),
             baseUrl: z.string().optional(),
             apiKey: z.string().optional(),
           })
         )
         .mutation(async ({ input }) => {
           const { id, ...rest } = input;
           const updatedModel = await prisma.model.update({
             where: { id },
             data: rest,
           });
           return updatedModel;
         }),

       deleteModel: protectedProcedure
         .input(z.object({ id: z.string() }))
         .mutation(async ({ input }) => {
           await prisma.model.delete({ where: { id: input.id } });
           return { success: true };
         }),
     });
     ```

4. ✅ **Create Eval Routers**  
   - Create a new file **`src/lib/api/routers/evalRouter.ts`**:
     ```ts
     import { z } from "zod";
     import { createTRPCRouter, protectedProcedure, publicProcedure } from "../trpc";
     import { prisma } from "@/lib/db";

     export const evalRouter = createTRPCRouter({
       generateEvals: protectedProcedure
         .input(
           z.object({
             prompt: z.string(),
             modelIds: z.array(z.string()),
           })
         )
         .mutation(async ({ input }) => {
           // For each model, call the AI endpoint to generate eval text
           // This is an example. You may adjust logic as needed.
           const { prompt, modelIds } = input;
           const newEvals = [];

           for (const modelId of modelIds) {
             // fetch the model info
             const model = await prisma.model.findUnique({ where: { id: modelId } });
             if (!model) continue;
             // call AI endpoint (stub):
             const generatedQuestion = `Question generated by model: ${model.name}. Prompt: ${prompt}`;
             // create the eval
             const createdEval = await prisma.eval.create({
               data: {
                 questionText: generatedQuestion,
                 creatorModelId: model.id,
               },
             });
             newEvals.push(createdEval);
           }

           return newEvals;
         }),

       listEvals: publicProcedure.query(async () => {
         return prisma.eval.findMany({
           include: {
             creatorModel: true,
           },
         });
       }),

       runEval: protectedProcedure
         .input(
           z.object({
             evalId: z.string(),
             modelIds: z.array(z.string()),
           })
         )
         .mutation(async ({ input }) => {
           const { evalId, modelIds } = input;
           const results = [];

           // find the eval
           const evalItem = await prisma.eval.findUnique({ where: { id: evalId } });
           if (!evalItem) {
             throw new Error("Eval not found");
           }

           // concurrently call each model
           const promises = modelIds.map(async (modelId) => {
             try {
               // fetch the model
               const model = await prisma.model.findUnique({ where: { id: modelId } });
               if (!model) {
                 return { modelId, error: "Model not found" };
               }
               // call AI endpoint (stub):
               const response = `Model ${model.name} answering: ${evalItem.questionText}`;
               // store result in DB
               const newResult = await prisma.result.create({
                 data: {
                   evalId: evalItem.id,
                   modelId: model.id,
                   responseText: response,
                 },
               });
               return newResult;
             } catch (e) {
               return { modelId, error: (e as Error).message };
             }
           });

           const results = await Promise.all(promises);
           return results;
         }),

       judgeEval: protectedProcedure
         .input(
           z.object({
             evalId: z.string(),
             modelIds: z.array(z.string()),
             ratingScaleMin: z.number().default(1),
             ratingScaleMax: z.number().default(10),
           })
         )
         .mutation(async ({ input }) => {
           const { evalId, modelIds, ratingScaleMin, ratingScaleMax } = input;
           const theEval = await prisma.eval.findUnique({ where: { id: evalId } });
           if (!theEval) throw new Error("Eval not found");
           const judgments = [];

           for (const modelId of modelIds) {
             try {
               // fetch the model
               const judgeModel = await prisma.model.findUnique({ where: { id: modelId } });
               if (!judgeModel) {
                 judgments.push({ modelId, error: "Model not found" });
                 continue;
               }
               // stub AI call to get a rating & justification:
               const randomScore = Math.floor(Math.random() * (ratingScaleMax - ratingScaleMin + 1)) + ratingScaleMin;
               const justification = `Judge model ${judgeModel.name} says this is a rating of ${randomScore} for question: ${theEval.questionText}`;
               // store judgment
               const newJudgment = await prisma.judgment.create({
                 data: {
                   evalId,
                   judgeModelId: judgeModel.id,
                   score: randomScore,
                   justificationText: justification,
                 },
               });
               judgments.push(newJudgment);
             } catch (e) {
               judgments.push({ modelId, error: (e as Error).message });
             }
           }
           return judgments;
         }),

       getLeaderboard: publicProcedure.query(async () => {
         // Example: get average result or score
         // For advanced logic, create additional logic or queries
         const [evalCount, judgmentCount] = await Promise.all([
           prisma.result.count(),
           prisma.judgment.count(),
         ]);

         return {
           totalResults: evalCount,
           totalJudgments: judgmentCount,
         };
       }),
     });
     ```

5. ✅ **Update Root Router**  
   - Open **`src/lib/api/root.ts`**.
   - Import and attach your new routers:
     ```ts
     import { createTRPCRouter } from "./trpc";
     import { modelRouter } from "./routers/modelRouter";
     import { evalRouter } from "./routers/evalRouter";

     export const appRouter = createTRPCRouter({
       model: modelRouter,
       evals: evalRouter,
     });

     export type AppRouter = typeof appRouter;

     export const createCaller = ...
     ```
   - Save the file.

6. **Add UI Pages**  
   - Create a new folder: **`src/app/models`**  
     - Inside it, create a file **`page.tsx`**:
       ```tsx
       import React from "react";
       import { api } from "@/lib/trpc/react";
       import { Button } from "@/components/Button";

       export default function ModelsPage() {
         const { data: models, refetch } = api.model.listModels.useQuery();
         const createModelMutation = api.model.createModel.useMutation({
           onSuccess: () => refetch(),
         });

         async function handleCreateModel() {
           await createModelMutation.mutateAsync({
             name: "My LLM",
             baseUrl: "https://api.example.com",
             apiKey: "fake-key",
           });
         }

         return (
           <div className="p-4">
             <h1 className="text-2xl font-bold mb-4">Models</h1>
             <Button onClick={handleCreateModel}>Add Model</Button>
             <ul className="mt-4">
               {models?.map((m) => (
                 <li key={m.id}>
                   {m.name} - {m.baseUrl}
                 </li>
               ))}
             </ul>
           </div>
         );
       }
       ```
   - Create a folder **`src/app/evals/generate`**  
     - Add **`page.tsx`**:
       ```tsx
       "use client";

       import React, { useState } from "react";
       import { api } from "@/lib/trpc/react";
       import { Button } from "@/components/Button";

       export default function GenerateEvalsPage() {
         const [prompt, setPrompt] = useState("");
         const [selectedModelIds, setSelectedModelIds] = useState<string[]>([]);
         const { data: models } = api.model.listModels.useQuery();
         const generateEvalsMutation = api.evals.generateEvals.useMutation();

         async function handleGenerate() {
           if (!prompt.trim()) return;
           await generateEvalsMutation.mutateAsync({
             prompt,
             modelIds: selectedModelIds,
           });
         }

         return (
           <div className="p-4">
             <h1 className="text-2xl font-bold mb-4">Generate Evals</h1>
             <textarea
               value={prompt}
               onChange={(e) => setPrompt(e.target.value)}
               placeholder="Enter a prompt..."
               className="block w-full p-2 mb-2 border border-gray-300 rounded"
             />
             <div className="flex flex-col gap-2 mb-4">
               <span>Select Models:</span>
               {models?.map((m) => (
                 <label key={m.id} className="flex items-center gap-2">
                   <input
                     type="checkbox"
                     onChange={(e) => {
                       if (e.target.checked) {
                         setSelectedModelIds((prev) => [...prev, m.id]);
                       } else {
                         setSelectedModelIds((prev) => prev.filter((id) => id !== m.id));
                       }
                     }}
                   />
                   {m.name}
                 </label>
               ))}
             </div>
             <Button onClick={handleGenerate}>Generate Evals</Button>
           </div>
         );
       }
       ```
   - Create a folder **`src/app/evals/run`**  
     - Add **`page.tsx`**:
       ```tsx
       "use client";

       import React, { useState } from "react";
       import { api } from "@/lib/trpc/react";
       import { Button } from "@/components/Button";

       export default function RunEvalsPage() {
         const { data: evals } = api.evals.listEvals.useQuery();
         const { data: models } = api.model.listModels.useQuery();
         const runEvalMutation = api.evals.runEval.useMutation();
         const [selectedEvalId, setSelectedEvalId] = useState("");
         const [selectedModelIds, setSelectedModelIds] = useState<string[]>([]);

         async function handleRun() {
           if (!selectedEvalId || selectedModelIds.length === 0) return;
           await runEvalMutation.mutateAsync({
             evalId: selectedEvalId,
             modelIds: selectedModelIds,
           });
         }

         return (
           <div className="p-4">
             <h1 className="text-2xl font-bold mb-4">Run Evals</h1>
             <div className="mb-4">
               <label>Select Eval:</label>
               <select
                 className="block w-full p-2 border border-gray-300 rounded"
                 value={selectedEvalId}
                 onChange={(e) => setSelectedEvalId(e.target.value)}
               >
                 <option value="">--Choose--</option>
                 {evals?.map((ev) => (
                   <option key={ev.id} value={ev.id}>
                     {ev.questionText}
                   </option>
                 ))}
               </select>
             </div>
             <div className="mb-4">
               <label>Select Models:</label>
               <div className="flex flex-col gap-1">
                 {models?.map((m) => (
                   <label key={m.id} className="flex items-center gap-2">
                     <input
                       type="checkbox"
                       onChange={(e) => {
                         if (e.target.checked) {
                           setSelectedModelIds((prev) => [...prev, m.id]);
                         } else {
                           setSelectedModelIds((prev) => prev.filter((id) => id !== m.id));
                         }
                       }}
                     />
                     {m.name}
                   </label>
                 ))}
               </div>
             </div>
             <Button onClick={handleRun}>Run</Button>
           </div>
         );
       }
       ```
   - Create a folder **`src/app/evals/judge`**  
     - Add **`page.tsx`**:
       ```tsx
       "use client";

       import React, { useState } from "react";
       import { api } from "@/lib/trpc/react";
       import { Button } from "@/components/Button";

       export default function JudgeEvalsPage() {
         const { data: evals } = api.evals.listEvals.useQuery();
         const { data: models } = api.model.listModels.useQuery();
         const judgeEvalMutation = api.evals.judgeEval.useMutation();
         const [selectedEvalId, setSelectedEvalId] = useState("");
         const [selectedModelIds, setSelectedModelIds] = useState<string[]>([]);
         const [ratingMin, setRatingMin] = useState(1);
         const [ratingMax, setRatingMax] = useState(10);

         async function handleJudge() {
           if (!selectedEvalId || selectedModelIds.length === 0) return;
           await judgeEvalMutation.mutateAsync({
             evalId: selectedEvalId,
             modelIds: selectedModelIds,
             ratingScaleMin: ratingMin,
             ratingScaleMax: ratingMax,
           });
         }

         return (
           <div className="p-4">
             <h1 className="text-2xl font-bold mb-4">Judge Mode</h1>
             <div className="mb-4">
               <label>Select Eval:</label>
               <select
                 className="block w-full p-2 border border-gray-300 rounded"
                 value={selectedEvalId}
                 onChange={(e) => setSelectedEvalId(e.target.value)}
               >
                 <option value="">--Choose--</option>
                 {evals?.map((ev) => (
                   <option key={ev.id} value={ev.id}>
                     {ev.questionText}
                   </option>
                 ))}
               </select>
             </div>
             <div className="mb-4">
               <label>Select Models:</label>
               <div className="flex flex-col gap-1">
                 {models?.map((m) => (
                   <label key={m.id} className="flex items-center gap-2">
                     <input
                       type="checkbox"
                       onChange={(e) => {
                         if (e.target.checked) {
                           setSelectedModelIds((prev) => [...prev, m.id]);
                         } else {
                           setSelectedModelIds((prev) => prev.filter((id) => id !== m.id));
                         }
                       }}
                     />
                     {m.name}
                   </label>
                 ))}
               </div>
             </div>
             <div className="flex gap-4 mb-4">
               <div>
                 <label>Rating Min:</label>
                 <input
                   type="number"
                   value={ratingMin}
                   onChange={(e) => setRatingMin(Number(e.target.value))}
                   className="block w-20 p-1 border border-gray-300 rounded"
                 />
               </div>
               <div>
                 <label>Rating Max:</label>
                 <input
                   type="number"
                   value={ratingMax}
                   onChange={(e) => setRatingMax(Number(e.target.value))}
                   className="block w-20 p-1 border border-gray-300 rounded"
                 />
               </div>
             </div>
             <Button onClick={handleJudge}>Judge</Button>
           </div>
         );
       }
       ```
   - Create a folder **`src/app/leaderboard`**  
     - Add **`page.tsx`**:
       ```tsx
       "use client";

       import React from "react";
       import { api } from "@/lib/trpc/react";

       export default function LeaderboardPage() {
         const { data: stats } = api.evals.getLeaderboard.useQuery();

         return (
           <div className="p-4">
             <h1 className="text-2xl font-bold mb-4">Leaderboard</h1>
             {stats ? (
               <div>
                 <p>Total Results: {stats.totalResults}</p>
                 <p>Total Judgments: {stats.totalJudgments}</p>
               </div>
             ) : (
               <p>Loading...</p>
             )}
           </div>
         );
       }
       ```

7. **Link Pages in UI**  
   - (Optional) Update **`src/app/page.tsx`** or any Nav component to link to these new routes:
     ```tsx
     // Example snippet
     <nav className="flex gap-4">
       <Link href="/models">Models</Link>
       <Link href="/evals/generate">Generate Evals</Link>
       <Link href="/evals/run">Run Evals</Link>
       <Link href="/evals/judge">Judge Evals</Link>
       <Link href="/leaderboard">Leaderboard</Link>
     </nav>
     ```

8. **(Optional) Add Parallel Execution and Error Handling**  
   - Within **`evalRouter.ts`** in the `runEval` procedure, you can replace the loop with a Promise.all if you prefer:
     ```ts
     const promises = modelIds.map(async (modelId) => {
       // ...
     });
     const results = await Promise.all(promises);
     ```
   - Ensure any error is caught and returned as needed.

9. **Build the Project**  
   - From the project root, run:
     ```bash
     npm run build
     ```

10. **Update `.cursor-updates`**  
    - Open **`.cursor-updates`**.
    - Append a one-sentence summary:
      ```markdown
      Added multi-model eval and judge features with dedicated pages and routes.
      ```

11. **Commit the Changes**  
    - Finally:
      ```bash
      git add .
      git commit -m "Implement LLM eval, judge, and leaderboard functionality"
      ```
