import { z } from "zod";
import { createTRPCRouter, protectedProcedure, publicProcedure } from "../trpc";
import { prisma } from "@/lib/db";

export const evalRouter = createTRPCRouter({
  generateEvals: protectedProcedure
    .input(
      z.object({
        prompt: z.string(),
        modelIds: z.array(z.string()),
      })
    )
    .mutation(async ({ input }) => {
      // For each model, call the AI endpoint to generate eval text
      // This is an example. You may adjust logic as needed.
      const { prompt, modelIds } = input;
      const newEvals = [];

      for (const modelId of modelIds) {
        // fetch the model info
        const model = await prisma.model.findUnique({ where: { id: modelId } });
        if (!model) continue;
        // call AI endpoint (stub):
        const generatedQuestion = `Question generated by model: ${model.name}. Prompt: ${prompt}`;
        // create the eval
        const createdEval = await prisma.eval.create({
          data: {
            questionText: generatedQuestion,
            creatorModelId: model.id,
          },
        });
        newEvals.push(createdEval);
      }

      return newEvals;
    }),

  listEvals: publicProcedure.query(async () => {
    return prisma.eval.findMany({
      include: {
        creatorModel: true,
      },
    });
  }),

  runEval: protectedProcedure
    .input(
      z.object({
        evalId: z.string(),
        modelIds: z.array(z.string()),
      })
    )
    .mutation(async ({ input }) => {
      const { evalId, modelIds } = input;

      // find the eval
      const evalItem = await prisma.eval.findUnique({ where: { id: evalId } });
      if (!evalItem) {
        throw new Error("Eval not found");
      }

      // concurrently call each model
      const promises = modelIds.map(async (modelId) => {
        try {
          // fetch the model
          const model = await prisma.model.findUnique({
            where: { id: modelId },
          });
          if (!model) {
            return { modelId, error: "Model not found" };
          }
          // call AI endpoint (stub):
          const response = `Model ${model.name} answering: ${evalItem.questionText}`;
          // store result in DB
          const newResult = await prisma.result.create({
            data: {
              evalId: evalItem.id,
              modelId: model.id,
              responseText: response,
            },
          });
          return newResult;
        } catch (e) {
          return { modelId, error: (e as Error).message };
        }
      });

      const evalResults = await Promise.all(promises);
      return evalResults;
    }),

  judgeEval: protectedProcedure
    .input(
      z.object({
        evalId: z.string(),
        modelIds: z.array(z.string()),
        ratingScaleMin: z.number().default(1),
        ratingScaleMax: z.number().default(10),
      })
    )
    .mutation(async ({ input }) => {
      const { evalId, modelIds, ratingScaleMin, ratingScaleMax } = input;
      const theEval = await prisma.eval.findUnique({ where: { id: evalId } });
      if (!theEval) throw new Error("Eval not found");

      const promises = modelIds.map(async (modelId) => {
        try {
          // fetch the model
          const judgeModel = await prisma.model.findUnique({
            where: { id: modelId },
          });
          if (!judgeModel) {
            return { modelId, error: "Model not found" };
          }
          // stub AI call to get a rating & justification:
          const randomScore =
            Math.floor(Math.random() * (ratingScaleMax - ratingScaleMin + 1)) +
            ratingScaleMin;
          const justification = `Judge model ${judgeModel.name} says this is a rating of ${randomScore} for question: ${theEval.questionText}`;
          // store judgment
          const newJudgment = await prisma.judgment.create({
            data: {
              evalId,
              judgeModelId: judgeModel.id,
              score: randomScore,
              justificationText: justification,
            },
          });
          return newJudgment;
        } catch (e) {
          return { modelId, error: (e as Error).message };
        }
      });

      const judgments = await Promise.all(promises);
      return judgments;
    }),

  getLeaderboard: publicProcedure.query(async () => {
    // Example: get average result or score
    // For advanced logic, create additional logic or queries
    const [evalCount, judgmentCount] = await Promise.all([
      prisma.result.count(),
      prisma.judgment.count(),
    ]);

    return {
      totalResults: evalCount,
      totalJudgments: judgmentCount,
    };
  }),
});
